<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POD Item Template Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
body {
    background-color: #f8f9fa;
    padding: 20px;
}

.container {
    padding: 20px;
}

.custom-card {
    max-width: 1600px;
    margin: 0 auto;
}

.card.custom-card {
    background-color: white;
    box-shadow: 0 .5rem 1rem rgba(0,0,0,.15) !important;
    border: none;
}

.card-header {
    background-color: #0d6efd;
    border-bottom: none;
    padding: 1rem;
}

.card-body {
    background-color: white;
    padding: 1.25rem;
}

/* Remove number input spinners */
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

input[type="number"] {
    -moz-appearance: textfield;
}

/* Toggle Switch Styles */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
}
.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}
.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: transparent;
    border: 2px solid white;
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 24px;
}
.slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 2px;
    bottom: 2px;
    background-color: white;  /* Changed from #6c757d to white */
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 50%;
}
input:checked + .slider:before {
    -webkit-transform: translateX(26px);
    -ms-transform: translateX(26px);
    transform: translateX(26px);
}
.toggle-label {
    color: white;
    font-size: 14px;
    font-weight: 500;
}
/* Button hover styles */
.hover-btn:hover {
    background-color: #0d6efd !important;
    color: white !important;
}

/* Table styles */
.table-responsive {
    margin-top: 1rem;
}

.table {
    margin-bottom: 0;
}

.table thead th {
    background-color: #f8f9fa;
    border-bottom: 2px solid #dee2e6;
}

/* Form field spacing */
.form-group {
    margin-bottom: 1rem;
}

.form-label {
    margin-bottom: 0.5rem;
}

/* Alert styling */
.alert {
    margin-bottom: 1rem;
}

.invalid-feedback {
    display: block;
}
/* Adjust table row font size */
.table tbody td {
    font-size: 0.85rem;  /* Reduced from default 1rem */
}

/* Keep header text at normal size */
.table thead th {
    font-size: 1rem;
}
/* Add or update these styles */
.table td:first-child {
    text-align: center;  /* Center horizontally */
    vertical-align: middle;  /* Center vertically */
    padding: 0;  /* Remove default padding */
}

.table td:first-child .btn {
    padding: 4px 8px;  /* Adjust button padding for better sizing */
    display: inline-flex;  /* Use flexbox */
    align-items: center;  /* Center icon vertically */
    justify-content: center;  /* Center icon horizontally */
}

.table td:first-child .btn i {
    margin: 0;  /* Remove any margin that might affect centering */
}

    </style>
</head>
<body>
<div class="container">
    <div class="card custom-card shadow">
        <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
            <h4 class="card-title mb-11">POD Item Template Manager</h4>
            <div class="d-flex align-items-center">
                <span class="toggle-label me-2">NEW</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="updateToggle">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label ms-2">UPDT</span>
                <button class="btn btn-outline-light ms-3" onclick="generateCSV()" id="downloadBtn" disabled>
                    <i class="bi bi-file-earmark-arrow-down me-1"></i>Generate CSV
                </button>
            </div>
        </div>
            <div class="card-body">
                <!-- Alert for errors -->
                <div class="alert alert-danger alert-dismissible fade show d-none" role="alert" id="error">
                    <span id="errorMessage"></span>
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>

                <!-- Form Fields -->
                <div class="row mb-3">
                    <div class="col-md-6">
                        <label for="isbn" class="form-label">ISBN</label>
                        <input type="text" class="form-control" id="isbn" placeholder="Enter 13-digit ISBN">
                    </div>
                    <div class="col-md-6">
                        <label for="title" class="form-label">Title (max 58 characters)</label>
                        <input type="text" class="form-control" id="title" maxlength="58">
                        <div class="form-text" id="titleCounter">0 / 58 characters</div>
                    </div>
                </div>

                <div class="row mb-3">
                    <div class="col-md-4">
                        <label for="trimHeight" class="form-label">Trim Height</label>
                        <input type="number" class="form-control" id="trimHeight">
                    </div>
                    <div class="col-md-4">
                        <label for="trimWidth" class="form-label">Trim Width</label>
                        <input type="number" class="form-control" id="trimWidth">
                    </div>
                    <div class="col-md-4">
                        <label for="pageExtent" class="form-label">Page Extent</label>
                        <input type="number" class="form-control" id="pageExtent">
                    </div>
                </div>

                <div class="row mb-3">
                    <div class="col-md-3">
                        <label for="paperType" class="form-label">Paper Type</label>
                        <select class="form-select" id="paperType">
                            <option value="">Select Paper Type</option>
                            <option value="amber_80">Amber Preprint 80 gsm</option>
                            <option value="woodfree_80">Woodfree 80 gsm</option>
                            <option value="munken_70">Munken Print Cream 70 gsm</option>
                            <option value="letsgo_90">LetsGo Silk 90 gsm</option>
                            <option value="matt_115">Matt 115 gsm</option>
                            <option value="holmen_60">Holmen Book Cream 60 gsm</option>
                            <option value="premium_mono_90">Premium Mono 90 gsm</option>
                            <option value="premium_color_90">Premium Colour 90 gsm</option>
                            <option value="mechanical_70">Mechanical Creamy 70 gsm</option>
                        </select>
                    </div>
                    <div class="col-md-3">
                        <label for="bindingStyle" class="form-label">Binding Style</label>
                        <select class="form-select" id="bindingStyle">
                            <option value="">Select Binding Style</option>
                            <option value="Limp">Limp</option>
                            <option value="Cased">Cased</option>
                        </select>
                    </div>
                    <div class="col-md-3">
                        <label for="spineSize" class="form-label">Spine Size</label>
                        <input type="number" class="form-control" id="spineSize" readonly>
                    </div>
                    <div class="col-md-3">
                        <label for="lamination" class="form-label">Lamination</label>
                        <select class="form-select" id="lamination">
                            <option value="">Select Lamination</option>
                            <option value="Gloss">Gloss</option>
                            <option value="Matt">Matt</option>
                        </select>
                    </div>
                </div>

                <button class="btn btn-outline-primary mb-4 hover-btn" onclick="addEntry()">
                    <i class="bi bi-plus-lg me-1"></i>Add Entry
                </button>
                
                <button class="btn btn-secondary mb-4 ms-2" onclick="clearFields()">
   				<i class="bi bi-x-lg me-1"></i>Clear Fields
				</button>

                <!-- Data Table -->
                <div class="table-responsive">
                    <table class="table table-bordered table-hover">
                        <thead class="table-light">
                            <tr>
                                <th style="width: 50px">Action</th>
                                <th>ISBN</th>
                                <th>Title</th>
                                <th>Trim Height</th>
                                <th>Trim Width</th>
                                <th>Spine Size</th>
                                <th>Paper Type</th>
                                <th>Binding Style</th>
                                <th>Page Extent</th>
                                <th>Lamination</th>
                            </tr>
                        </thead>
                        <tbody id="entriesTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <script>
        // Paper specifications
        const PAPER_SPECS = {
            amber_80: { name: 'Amber Preprint 80 gsm', grammage: 80, volume: 13 },
            woodfree_80: { name: 'Woodfree 80 gsm', grammage: 80, volume: 17.5 },
            munken_70: { name: 'Munken Print Cream 70 gsm', grammage: 70, volume: 18 },
            letsgo_90: { name: 'LetsGo Silk 90 gsm', grammage: 90, volume: 10 },
            matt_115: { name: 'Matt 115 gsm', grammage: 115, volume: 11 },
            holmen_60: { name: 'Holmen Book Cream 60 gsm', grammage: 60, volume: 18 },
            premium_mono_90: { name: 'Premium Mono 90 gsm', grammage: 90, volume: 9.7 },
            premium_color_90: { name: 'Premium Colour 90 gsm', grammage: 90, volume: 9.7 },
            mechanical_70: { name: 'Mechanical Creamy 70 gsm', grammage: 70, volume: 20 }
        };

        // Constants for validation
        const NARROW_WIDTH_THRESHOLD = 156;
        const SPINE_CALCULATION_FACTOR = 20000;
        const HARDBACK_SPINE_ADDITION = 4;

        // Calculate adjusted page extent
        function calculatePageExtent(originalExtent, trimWidth) {
            const divisor = trimWidth <= NARROW_WIDTH_THRESHOLD ? 6 : 4;
            return Math.ceil(originalExtent / divisor) * divisor;
        }

        // Validate page extent
        function validatePageExtent() {
            const pageExtentInput = document.getElementById('pageExtent');
            const trimWidthInput = document.getElementById('trimWidth');
            
            const pageExtent = parseInt(pageExtentInput.value);
            const trimWidth = parseInt(trimWidthInput.value);

            if (!pageExtent || !trimWidth) return;

            const divisor = trimWidth <= NARROW_WIDTH_THRESHOLD ? 6 : 4;
            
            if (pageExtent % divisor !== 0) {
                const adjustedValue = calculatePageExtent(pageExtent, trimWidth);
                const message = `For trim width ${trimWidth}mm, page extent must be divisible by ${divisor}. 
                               Would you like to adjust ${pageExtent} to ${adjustedValue}?`;
                
                // Create modal for warning
                const modalHtml = `
                    <div class="modal fade" id="pageExtentModal" tabindex="-1">
                        <div class="modal-dialog">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title">Page Extent Warning</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                                </div>
                                <div class="modal-body">
                                    <p>${message}</p>
                                </div>
                                <div class="modal-footer">
                                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Keep Current</button>
                                    <button type="button" class="btn btn-primary" onclick="adjustPageExtent(${adjustedValue})">
                                        Adjust to ${adjustedValue}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>`;

                // Remove existing modal if any
                const existingModal = document.getElementById('pageExtentModal');
                if (existingModal) {
                    existingModal.remove();
                }

                // Add new modal to document
                document.body.insertAdjacentHTML('beforeend', modalHtml);

                // Show modal
                const modal = new bootstrap.Modal(document.getElementById('pageExtentModal'));
                modal.show();

                return false;
            }
            return true;
        }

        // Function to adjust page extent
        function adjustPageExtent(newValue) {
            document.getElementById('pageExtent').value = newValue;
            const modal = bootstrap.Modal.getInstance(document.getElementById('pageExtentModal'));
            if (modal) {
                modal.hide();
            }
            updateSpineSize();
        }

        // Add event listeners for validation
        document.getElementById('pageExtent').addEventListener('change', validatePageExtent);
        document.getElementById('trimWidth').addEventListener('change', validatePageExtent);
        function calculateSpineSize(pageExtent, paperType, bindingStyle) {
    	const paperSpecs = PAPER_SPECS[paperType];
    	if (!paperSpecs) return 0;

    	const baseSpineThickness = Math.round(
        (pageExtent * paperSpecs.grammage * paperSpecs.volume) / SPINE_CALCULATION_FACTOR
    	);

    	return bindingStyle.toLowerCase() === 'cased' 
        ? baseSpineThickness + HARDBACK_SPINE_ADDITION 
        : baseSpineThickness;
}

        // Auto-calculate page extent
        document.getElementById('trimWidth').addEventListener('input', function() {
            const pageExtentInput = document.getElementById('pageExtent');
            const originalExtent = parseInt(pageExtentInput.value) || 0;
            if (originalExtent > 0) {
                const adjustedExtent = calculatePageExtent(originalExtent, parseInt(this.value) || 0);
                pageExtentInput.value = adjustedExtent;
                // Recalculate spine size if all necessary fields are filled
                updateSpineSize();
            }
        });

        // Update spine size when relevant fields change
        function updateSpineSize() {
    	const pageExtent = parseInt(document.getElementById('pageExtent').value) || 0;
   		 const paperType = document.getElementById('paperType').value;
   		 const bindingStyle = document.getElementById('bindingStyle').value;

   		if (pageExtent && paperType && bindingStyle) {
        const spineSize = calculateSpineSize(pageExtent, paperType, bindingStyle);
        document.getElementById('spineSize').value = spineSize;
   		 	}
		}
        // Add event listeners for spine size calculation
        ['pageExtent', 'paperType', 'bindingStyle'].forEach(id => {
    	document.getElementById(id).addEventListener('change', updateSpineSize);
		});

        // Store entries
        let entries = [];

        // ISBN validation
        function isValidISBN(isbn) {
            const cleaned = isbn.replace(/[-\s]/g, '');
            
            // Check length
            if (cleaned.length !== 13) {
                return { isValid: false, error: 'ISBN must be exactly 13 digits' };
            }
            
            // Check if all characters are digits
            if (!/^\d{13}$/.test(cleaned)) {
                return { isValid: false, error: 'ISBN must contain only digits' };
            }
            
            // Check prefix
            if (!cleaned.startsWith('978') && !cleaned.startsWith('979')) {
                return { isValid: false, error: 'ISBN must start with 978 or 979' };
            }
            
            // Check checksum
            let sum = 0;
            for (let i = 0; i < 12; i++) {
                sum += parseInt(cleaned[i]) * (i % 2 === 0 ? 1 : 3);
            }
            const checkDigit = (10 - (sum % 10)) % 10;
            
            if (checkDigit !== parseInt(cleaned[12])) {
                return { isValid: false, error: 'Invalid ISBN checksum' };
            }
            
            return { isValid: true, error: '' };
        }

        // Add real-time ISBN validation
        document.getElementById('isbn').addEventListener('input', function() {
            const validation = isValidISBN(this.value);
            if (!validation.isValid) {
                this.classList.add('is-invalid');
                // Remove existing feedback if any
                const existingFeedback = document.getElementById('isbn-feedback');
                if (existingFeedback) existingFeedback.remove();
                
                // Add new feedback
                const feedback = document.createElement('div');
                feedback.className = 'invalid-feedback d-block';
                feedback.id = 'isbn-feedback';
                feedback.textContent = validation.error;
                this.parentNode.appendChild(feedback);
            } else {
                this.classList.remove('is-invalid');
                const feedback = document.getElementById('isbn-feedback');
                if (feedback) feedback.remove();
            }
        });

        // Update title character counter with immediate validation
        document.getElementById('title').addEventListener('input', function() {
            const counter = document.getElementById('titleCounter');
            const length = this.value.length;
            counter.textContent = `${length} / 58 characters`;
            
            if (length > 58) {
                counter.classList.add('text-danger');
                this.classList.add('is-invalid');
                // Remove existing feedback if any
                const existingFeedback = document.getElementById('title-feedback');
                if (existingFeedback) existingFeedback.remove();
                
                // Add new feedback
                const feedback = document.createElement('div');
                feedback.className = 'invalid-feedback d-block';
                feedback.id = 'title-feedback';
                feedback.textContent = 'Title cannot exceed 58 characters';
                this.parentNode.appendChild(feedback);
            } else {
                counter.classList.remove('text-danger');
                this.classList.remove('is-invalid');
                const feedback = document.getElementById('title-feedback');
                if (feedback) feedback.remove();
            }
        });

        // Validate and highlight field
        function validateField(id, condition, errorMessage) {
            const field = document.getElementById(id);
            if (!condition) {
                field.classList.add('is-invalid');
                if (!document.getElementById(`${id}-feedback`)) {
                    const feedback = document.createElement('div');
                    feedback.className = 'invalid-feedback';
                    feedback.id = `${id}-feedback`;
                    feedback.textContent = errorMessage;
                    field.parentNode.appendChild(feedback);
                }
                return false;
            }
            field.classList.remove('is-invalid');
            const feedback = document.getElementById(`${id}-feedback`);
            if (feedback) feedback.remove();
            return true;
        }

        // Reset field validation
        function resetFieldValidation(id) {
            const field = document.getElementById(id);
            field.classList.remove('is-invalid');
            const feedback = document.getElementById(`${id}-feedback`);
            if (feedback) feedback.remove();
        }

        // Add entry to table
        function addEntry() {
            let isValid = true;
            
            // Validate ISBN
            const isbn = document.getElementById('isbn').value;
            const isbnValidation = isValidISBN(isbn);
            isValid = validateField('isbn', isbnValidation.isValid, isbnValidation.error) && isValid;

            // Validate Title
            const title = document.getElementById('title').value;
            isValid = validateField('title', title.length > 0 && title.length <= 58, 
                title.length === 0 ? 'Title is required' : 'Title cannot exceed 58 characters') && isValid;

            // Validate other required fields
            const requiredFields = [
                { id: 'trimHeight', name: 'Trim Height' },
                { id: 'trimWidth', name: 'Trim Width' },
                { id: 'paperType', name: 'Paper Type' },
                { id: 'bindingStyle', name: 'Binding Style' },
                { id: 'pageExtent', name: 'Page Extent' },
                { id: 'lamination', name: 'Lamination' }
            ];

            requiredFields.forEach(field => {
                const value = document.getElementById(field.id).value;
                isValid = validateField(field.id, value.trim() !== '', `${field.name} is required`) && isValid;
            });

            if (!isValid) {
                showError('Please fill in all required fields correctly');
                return;
            }

            const paperTypeSelect = document.getElementById('paperType');
            const bindingStyleSelect = document.getElementById('bindingStyle');
            const laminationSelect = document.getElementById('lamination');

            const entry = {
                isbn: isbn,
                title: title,
                trimHeight: document.getElementById('trimHeight').value,
                trimWidth: document.getElementById('trimWidth').value,
                spineSize: document.getElementById('spineSize').value,
                paperType: paperTypeSelect.options[paperTypeSelect.selectedIndex].text,
                bindingStyle: bindingStyleSelect.options[bindingStyleSelect.selectedIndex].text,
                pageExtent: document.getElementById('pageExtent').value,
                lamination: laminationSelect.options[laminationSelect.selectedIndex].text
            };

            entries.push(entry);
            updateTable();
            resetForm();
            enableDownloadButton();
        }

        // Update table display
        function updateTable() {
            const tbody = document.getElementById('entriesTableBody');
            tbody.innerHTML = '';

            entries.forEach((entry, index) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>
                        <button class="btn btn-danger btn-sm" onclick="deleteEntry(${index})">
                            <i class="bi bi-trash"></i>
                        </button>
                    </td>
                    <td>${entry.isbn}</td>
                    <td>${entry.title}</td>
                    <td>${entry.trimHeight}</td>
                    <td>${entry.trimWidth}</td>
                    <td>${entry.spineSize}</td>
                    <td>${entry.paperType}</td>
                    <td>${entry.bindingStyle}</td>
                    <td>${entry.pageExtent}</td>
                    <td>${entry.lamination}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        // Delete entry
        function deleteEntry(index) {
            entries.splice(index, 1);
            updateTable();
            enableDownloadButton();
        }

        // Reset form
        function resetForm() {
            const fields = ['isbn', 'title', 'trimHeight', 'trimWidth', 'spineSize', 
                          'paperType', 'bindingStyle', 'pageExtent', 'lamination'];
            
            fields.forEach(field => {
                const element = document.getElementById(field);
                element.value = '';
                resetFieldValidation(field);
            });
            
            document.getElementById('titleCounter').textContent = '0 / 58 characters';
        }

        // Show error message
        function showError(message) {
            const error = document.getElementById('error');
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            error.classList.remove('d-none');
        }

        // Enable/disable download button
        function enableDownloadButton() {
            document.getElementById('downloadBtn').disabled = entries.length === 0;
        }
        
        // Clear Form Button
        function clearFields() {
    	const fields = ['isbn', 'title', 'trimHeight', 'trimWidth', 'spineSize', 
                   'paperType', 'bindingStyle', 'pageExtent', 'lamination'];
    
    	fields.forEach(field => {
        const element = document.getElementById(field);
        element.value = '';
        element.classList.remove('is-invalid');
        const feedback = document.getElementById(`${field}-feedback`);
        if (feedback) feedback.remove();
    	});
    
    	document.getElementById('titleCounter').textContent = '0 / 58 characters';
		}

        // Handle file upload
        document.getElementById('fileUpload').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const data = await file.arrayBuffer();
                const workbook = XLSX.read(data, {
                    type: 'array',
                    cellDates: true,
                    cellNF: true,
                    cellText: true
                });

                const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, {
                    raw: false,
                    defval: ''
                });

                // Clear existing entries
                entries = [];

                // Process each row
                jsonData.forEach(row => {
                    const isbn = row['ISBN'] || '';
                    if (!isbn || !isValidISBN(isbn)) {
                        console.warn(`Skipping row with invalid ISBN: ${isbn}`);
                        return;
                    }

                    // Parse numeric values
                    const trimWidth = parseInt(row['Trim Width']) || 0;
                    let pageExtent = parseInt(row['Page Extent']) || 0;
                    const adjustedPageExtent = calculatePageExtent(pageExtent, trimWidth);

                    // Get paper specs for spine calculation
                    const paperType = row['Paper'];
                    const paperTypeKey = Object.keys(PAPER_SPECS).find(key => 
                        PAPER_SPECS[key].name === paperType
                    );

                    // Calculate spine size
                    const spineSize = paperTypeKey ? calculateSpineSize(
                        adjustedPageExtent, 
                        paperTypeKey, 
                        row['Binding'].toLowerCase()
                    ) : 0;

                    const entry = {
                        isbn: isbn,
                        title: row['Title'] || '',
                        trimHeight: row['Trim Height'] || '',
                        trimWidth: trimWidth.toString(),
                        spineSize: spineSize.toString(),
                        paperType: paperType || '',
                        bindingStyle: row['Binding'] || '',
                        pageExtent: adjustedPageExtent.toString(),
                        lamination: row['Lamination'] || ''
                    };

                    if (entry.title.length <= 58) {
                        entries.push(entry);
                    } else {
                        console.warn(`Skipping row with title exceeding 58 characters: ${entry.title}`);
                    }
                });

                updateTable();
                enableDownloadButton();
                this.value = '';
                
                if (entries.length > 0) {
                    showError(`Successfully imported ${entries.length} entries`);
                } else {
                    showError('No valid entries found in the Excel file');
                }
            } catch (error) {
                console.error('Error processing Excel file:', error);
                showError('Error processing Excel file: ' + error.message);
            }
        });
        
        document.getElementById('updateToggle').addEventListener('change', function() {
    const label = document.getElementById('toggleLabel');
    label.textContent = this.checked ? 'UPDT' : 'NEW';
});

        	// Generate CSV function - placeholder for your specific format
			function generateCSV() {
    if (entries.length === 0) {
        showError('No entries to export');
        return;
    }

    try {
        // Simply check if the toggle is checked
        const isChecked = document.getElementById('updateToggle').checked;
        const action = isChecked ? 'UPDT' : 'NEW';

        let csvRows = entries.map(entry => {
            // Get paper specs for grammage
            const paperTypeKey = Object.keys(PAPER_SPECS).find(key => 
                PAPER_SPECS[key].name === entry.paperType
            );
            const grammage = paperTypeKey ? PAPER_SPECS[paperTypeKey].grammage.toString() : '';

            // Format each row according to template format
            return [
                'ISBN',                      // Static 'ISBN'
                action,                      // NEW or UPDT based on toggle
                entry.isbn,                  // ISBN value
                entry.title,                 // Title
                entry.bindingStyle,          // Binding style (Limp/Cased)
                entry.lamination,            // Lamination (Gloss/Matt)
                entry.trimHeight,            // Height (234)
                entry.trimWidth,             // Width (156)
                entry.spineSize,             // Spine size
                entry.pageExtent,            // Page extent
                grammage,                    // Paper grammage from specs
                entry.paperType,             // Paper type
                'N'                          // Static 'N'
            ].map(value => value.toString()).join(',');
        });

        // Create blob and trigger download
        const csvContent = csvRows.join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        
        // Generate filename with timestamp
        const timestamp = new Date().toISOString()
            .replace(/[:.]/g, '_')            // Replace : and . with _
            .replace('T', '_')                // Replace T with _
            .replace('Z', '');                // Remove Z
            
        const filename = `itemTemplate${timestamp}.csv`;

        // Create download link
        const link = document.createElement('a');
        if (link.download !== undefined) {
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    } catch (error) {
        console.error('Error generating CSV:', error);
        showError('Error generating CSV file');
    }
}
    </script>
</body>
</html>